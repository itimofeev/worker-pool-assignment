# Worker Pool Assignment

Необходимо реализовать пул воркеров для обработки задач.
Добавление задачи должно быть неблокирующим.
Пул должен иметь возможностью динамически изменять количество воркеров. 
Результат обработки должен возвращаться асинхронно.
В качестве дополнительного задания добавить возможность делать grace shutdown.

```go
type Job interface {
    ID() string
    Do() error
}

type JobResult struct {
    JobID string
    Err   error
}

type WorkerPool interface {
    Start(ctx context.Context)
    AddWorkers(count int)
    RemoveWorkers(count int)
    AddJob(job Job)
    Subscribe() chan JobResult
}
```

## Как запустить тесты
1. `go mod download`
2. `make test` запустит тесты с флагом -race, чтобы проверить, что нет гонок

## Описание работы методов
1. Инициализация пула происходит методом `pool.Start(ctx)`, который сохраняет контекст и будет слушать, когда он закроектся. После этого пул начнёт graceful shutdown, т.е. прекратит принимать новые задачи и завершит работу, когда воркеры обработают уже добавленные задачи.
2. Добавление воркеров происходит методом `pool.AddWorkers`, в результате которого запускается необходимое количество горутин, слушающих канал с Job. Каждый worker добавляется в мапу, чтобы потом можно было понять, когда все воркеры остановлены.
3. Удаление воркеров происходит методом `pool.RemoveWorkers`. Контексты случайных воркеров (тех что вернёт итерация по мапе) будут закенселены. По завершении обработки текущей задачи, воркер оповестит пул через канал, что он завершился. Пул удалит его из мапы воркеров.
4. Добавление задачи происходит методов `pool.AddJob`. Job добавляется в канал jobsCh, из которого какой-то из воркеров возьмёт задание на обработку. Добавление job может не произойти по двум причинам: либо буфер задач в обработке переполнен, либо пул останавливается.

## Предложения по изменению интерфейса WorkerPool
1. Метод AddJob может не добавить задачу на обработку в случае, если буффер задач переполнен. Чтобы отлавливать такие ситуации, можно было бы возвращать булево значение, было ли добавлено значение или нет.
2. ctx в методе Start нужен для того, чтобы можно было остановить pool, когда контекст закрывается. Пользователи пула могут неправильно использовать этот метод, например не вызвав его вообще или вызвав несколько раз. Этого можно было бы избежать, передавая контекст в конструкторе всегда и только один раз.
3. Метод `Subscribe() chan worker.JobResult` можно было бы определить как receive only канал `Subscribe() <-chan worker.JobResult`

## Что нужно учитывать при использовании пула
1. Задача может не добавится в очередь выполнения и вызывающий метод никак об этом не узнает при текущем интерфейсе
2. Нужно стараться обрабатывать результаты по возможности быстро. Иначе буффер канала с результатами может переполниться и обработка задач заблокируется на записи в канал результатов. Можно было бы скипать запись в таком случае через неблокирующую запись в канал, но это может быть нежелательным поведением.